name: Dependabot Auto-merge

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  check_suite:
    types: [completed]

permissions:
  pull-requests: write
  contents: write
  checks: read
  statuses: read

concurrency:
  group: dependabot-automerge-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  automerge:
    if: github.event.pull_request.user.login == 'dependabot[bot]'
    runs-on: ubuntu-latest

    steps:
      - name: Read Dependabot metadata
        id: meta
        uses: dependabot/fetch-metadata@v2

      - name: Skip major and 0.x minor/patch updates
        uses: actions/github-script@v7
        id: skip
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            const updateType = "${{ steps.meta.outputs.update-type }}";

            // Dependabot metadata
            const nameMatch = pr.title.match(/bump (\S+) from/);
            const versionMatch = pr.title.match(/ to ([0-9]+\.[0-9]+\.[0-9]+)/);

            const depName = nameMatch ? nameMatch[1] : null;
            const depVersion = versionMatch ? versionMatch[1] : null;

            if (!depName || !depVersion) {
              core.notice(`Could not parse dependency or version from PR title '${pr.title}' → skipping`);
              process.exit(0); // safe skip
            }

            // If it's a major update → skip
            if (updateType === "version-update:semver-major") {
              core.notice(`Major update for ${depName} → manual review required.`);
              process.exit(0);
            }

            // If it's semver-minor/patch BUT major is 0 → skip too
            const major = parseInt(depVersion.split(".")[0], 10);
            if (major === 0) {
              core.notice(`0.x update for ${depName} (${depVersion}) → manual review required.`);
              process.exit(0);
            }

      - name: Wait until PR is mergeable
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTO_MERGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;

            async function getPR() {
              return (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
            }

            let tries = 10;
            let prData;
            while (tries-- > 0) {
              prData = await getPR();
              if (prData.mergeable_state && prData.mergeable_state !== 'unknown') break;
              await new Promise(r => setTimeout(r, 3000));
            }

            core.setOutput("mergeable", prData.mergeable);
            core.setOutput("mergeable_state", prData.mergeable_state);
            core.setOutput("head_ref", prData.head.ref);
            core.setOutput("sha", prData.head.sha);

      - name: Verify checks and statuses
        id: checks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const sha = "${{ steps.pr.outputs.sha }}";

            const combined = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha });
            const statuses = combined.statuses || [];
            const statusesOK = (combined.state === 'success' || statuses.length === 0);

            let checksOK = true;
            try {
              const checks = await github.rest.checks.listForRef({ owner, repo, ref: sha, filter: 'latest' });
              const ok = new Set(['success','neutral','skipped']);
              checksOK = checks.data.check_runs.every(cr => ok.has(cr.conclusion || 'success'));
            } catch (e) {
              core.warning(`Checks API not fully available: ${e.message}`);
            }

            core.info(`statusesOK: ${statusesOK}, checksOK: ${checksOK}`);

            if (!statusesOK || !checksOK) {
              core.notice(`Checks failed → skipping merge
              statusesOK: ${statusesOK}, checksOK: ${checksOK}`);
              process.exit(0);
            }

      - name: Merge PR (squash)
        if: |
          steps.meta.outputs.update-type == 'version-update:semver-patch' ||
          steps.meta.outputs.update-type == 'version-update:semver-minor'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTO_MERGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;

            await github.rest.pulls.merge({
              owner, repo, pull_number: number, merge_method: 'squash'
            });

      - name: Delete branch (Best effort)
        if: always()
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const ref = "heads/${{ steps.pr.outputs.head_ref }}";

            try {
              await github.rest.git.deleteRef({ owner, repo, ref });
            } catch (e) {
              core.warning(`Could not delete branch: ${e.message}`);
            }
